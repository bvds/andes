// coldriver.cpp
// Copyright (C) 2001 by Joel A. Shapiro -- All Rights Reserved
// Modifications by Brett van de Sande, 2005-2008
//
//  This file is part of the Andes Solver.
//
//  The Andes Solver is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  The Andes Solver is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with the Andes Solver.  If not, see <http://www.gnu.org/licenses/>.

//	solve equations for problem in Andes2,
//	from files generated by Collin, 1/29/01
//	Just as list2 but for new solver format
#define IAmMain
#include <stdio.h>
#include "coldriver.h"
#include "extstruct.h"
#include "decl.h"
#include "unitabr.h"
#include "indyset.h"
#include "indysgg.h"
#include "dbg.h"
#include <iostream>
#include <sstream>
#include "justsolve.h"

bool handleInput(std::string& aLine);
void doinitinit();  // this is defined below
int checksol(const binopexp * const eqexpr, const vector<double> * const sols,
	     const double reltverr);
void dimchkeqf(iostream & outstr);

extern vector<valander *> *canongrads;

bool isFirst = true;		// instantiation moved here by Linn
//////////////////////////////////////////////////////////////////////////////
// static/local error messages reurned for copying
const char* error[] = {
	"Unable to read source file",
	"Unable to write destination file",
	"Unexpected Input",
	"So far so good",
	"nil",
};
char lzbfr[4096]; // major kludge but this needs to be rewritten once
// it's in working anyway
stringstream resultBuffer;     // hold output in string buffer.

void constsfill();
extern unitabrs unittable;

/************************************************************************
 * solveTheProblem							*
 *	Assumes the equations and variables have already been entered	*
 *	solves the problem, writing the solution in TEMP_FILE, 		*
 *	including the tags and problem statements if the problem was	*
 *	not completely solved.						*
 *   Then it opens the file for reading, and returns the first line	*
 *	[does not close file]						*
 ************************************************************************/
const char* solveTheProblem() {
  int k;

  if (isFirst) throw string("solveTheProblem called before initialization");
  try {
    // reset the buffer to be empty
    resultBuffer.str(string());
    if(resultBuffer.good()) {
      numsols->assign(canonvars->size(),HUGE_VAL);
      if (solveeqs(resultBuffer)) {
	// should we do checking of solution here?
	bool discrep = false;
	for (k = 0; k < canoneqf->size(); k++) {
	  if (checksol((*canoneqf)[k],numsols,RELERR) > 1) {
	    if (!discrep) {
	      resultBuffer << "<DISCREPANCIES>" << endl;
	      discrep = true;
	    }
	    resultBuffer << (*canoneqf)[k]->getInfix() << endl;
	  }
	} // loop over equations to check
	dimchkeqf(resultBuffer);
	// end of "should we do checking of solution here?"
      }
    } 
    else throw string("unable to create solution buffer");
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("solveTheProblem went boom!!"); }

  // this would be a good place to insert checksol ? or after returning
  // solution, in solveMoreOfTheProblem ?
  try {
    resultBuffer.clear();
    resultBuffer.seekg(0);
    int tk;
    try { tk = resultBuffer.eof(); } 
    catch (...) { throw string("eof?!?"); }
    if (! tk) {
      string t;
      try { t = getaline(resultBuffer); }
      catch (...) { throw string("getaline fails???"); }
      try { sprintf(lzbfr, "%s", t.c_str()); } 
      catch(...) { throw string("copy is wrong??"); }
      return lzbfr;
    } 
    else return error[4];
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("Read went bad!!"); }
  return error[3];
}

/************************************************************************
 * solveMoreOfTheProblem						*
 *	reads one line from the opened solution file, 			*
 *	if that line is empty, closes file, returns nil			*
 *	if not, returns it						*
 *	if EOF, closes file and returns nil				*
 *	I don't understand when is returns "So far so good"		*
 ************************************************************************/
const char* solveMoreOfTheProblem() {
  try {
    if (! resultBuffer.eof()) {
      string t = getaline(resultBuffer);
      if (t.size() == 0) {
        resultBuffer.clear();
	return error[4];	// if checksol after returning sol, here+below
      } // end of if line empty, which closes and returns
      else sprintf(lzbfr, "%s", t.c_str());
      return lzbfr;
    } // end of not eof. 
    else {
      resultBuffer.clear();
      return error[4];	// if checksol after returning sol, here and above
    }
  } catch (string message) {
    resultBuffer.clear();
    throw message;
  } catch (...) {
    resultBuffer.clear();
      throw string("More went bad!!");
  }
  return error[3];
}


bool handleInput(std::string& aLine) {
  try {
    if (isFirst) doinitinit();
    bool result = true;
    if (!aLine.empty()) result = getall(aLine);
  return result; // Unexpected input
  } 
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

void indyEmpty();
bool clearTheProblem() {
  try {
    indyEmpty();
    isFirst = false;
    return true;
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

extern bool setupdone;

void doinitinit() {
  try {
    isFirst = false;
    setupdone = false;
    indyEmpty(); 
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("InitInit is broken"); }
}
